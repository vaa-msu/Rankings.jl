# Rankings.jl

Пакет в своём нынешнем виде предназначен для максимального упрощения работы
с ранжированиями в Julia-программах. Он «воспринимает» привычные исследователю описания
ранжирований и формирует на их основе необходимые для дальнейшей работы т.н. матрицы
потерь, избавленные от избыточной информации и потому именуемые здесь «облегчёнными».


## Макрос «чтения» ранжирований

Строка, задающая ранжирование, -- помимо специального префикса -- содержит набор
альтернатив, а также информацию о «взаимоотношениях» между ними в ранжировании.
Основная (неявно присутствующая) информация -- это порядок (предпочтительности)
альтернатив: чем ранее какая-либо альтернатива расположена в строке, тем она, вообще
говоря, предпочтительнее (`ranking"O₂,O₃,O₄,O₁,O₅"`). Перечислены альтернативы могут быть
через пробел или через запятую, что означает, что они следуют в порядке предпочтительности;
можно также явно употребить часто встречающийся в этой ситуации символ «предшествования» `≻`
(он вводится как `\succ[Tab]`): `ranking"b≻e≻d≻c≻a"`. Возможны (но по понятным причинам
не очень рекомендуются) различные «смешанные» варианты употребления этих символов.

Если некоторые альтернативы являются равноценными, то они, следуя в каком-либо порядке,
выделяются специальным образом: либо разделительными символами «равноценности» `∼`
(вводятся как `\sim[Tab]`) или просто символами «тильда»: `ranking"R N T P∼I C G∼D K O H J Q S∼M B E A F L"`,
либо заключаются в круглые скобки: `ranking"(O₂,O₃),O₄,(O₁,O₅)"`.

Альтернативы могут обозначаться (как это обычно принято) буквами и буквами с дополнительными
цифровыми символами (обычными или в виде нижних индексов), что охватывает значительную
часть примеров, найденных в литературе. На самом деле называть альтернативу
можно и произвольным именем, допустимым в языке Julia (более точно: последовательностью
Unicode-символов, опознаваемой анализатором из пакета `Tokenize.jl` как идентификатор).

Упомянутый пакет используется при разборе строки с описанием ранжирования, что позволяет
обнаруживать в ней элементарные фрагменты кода Julia (в данном случае -- допустимые
идентификаторы, что весьма существенно, учитывая сложность их построения в языке, а также
символы некоторых операций и круглые скобки). Правда, не все символы воспринимаются пакетом
так, как хотелось бы: в частности, выбранный для обозначения равноценности альтернатив
символ `∼` (вводится как `\sim[Tab]`), порождает ошибку разбора, появление которой затем
корректируется в функции `parse_tokens!()` модуля `Rankings.jl`), 

Если альтернатив не очень много, а все ранжирования -- строгие (без равноценных альтернатив), можно записывать всё вообще без лишних символов, обозначая альтернативы одиночными буквами
(`ranking"AIFDHCBEJG"`, `ranking"βαγ"`) или даже цифрами (`ranking"541632"`).
Это возможно, поскольку в случае отсутствия основных разделительных символов
(`,`,`≻`,`~`,`∼`,`(`,`)`) и пробелов строка описания не анализируется с помощью функций
из `Tokenize.jl`, а просто разбивается на отдельные символы, после чего уже несущественно,
являются ли они допустимыми идентификаторами.

> Лучше всего придерживаться простого правила: обозначать альтернативы именами,
> следующими в алфавитном порядке. Тогда используемый и ожидаемый порядки перечисления
> альтернатив в процессе работы будут совпадать и никаких дополнительных действий
> никогда не понадобится. Скажем, в случае большого количества альтернатив с нижними
> индексами предпочтительно использование сразу двухзначных (или более) индексов:
> `ranking"P₀₈,P₁₁,P₀₃,P₀₂,P₀₁∼P₀₄∼P₀₅∼P₀₆∼P₁₀∼P₁₂∼P₁₃,P₀₉,P₀₇∼P₁₄"`.

Поскольку язык Julia позволяет сопоставить строкам символов обрабатывающую их процедуру,
появляется возможность преобразовывать их нужным образом для использования в программах.
Сопоставление достигается выбором ещё не используемого (в Julia) префикса
для подлежащих преобразованию строк (здесь был выбран префикс `ranking`),
после чего перед компиляцией кода с такими строками будет вызываться макрос
с именем, составленным из этого префикса и суффикса `_str` (т.е., `@ranking_str`),
который должен быть предварительно определён (что и сделано в пакете `Rankings.jl`).

Строка-описание ранжирования преобразуется макросом в словарь, где каждому обозначению
альтернативы ставится в соответствие целое значение, отсчитываемое от нуля
в сторону уменьшения, -- так, чтобы самая предпочтительная альтернатива имела
условное значение 0, а все последующие -- соответствующие своему (более низкому)
«рангу» отрицательные значения.


## Русскоязычный вариант макроса

Наряду с англоязычным названием макроса `@ranking_str`, обрабатывающего строки вида
`ranking" "`, имеется также совершенно аналогичный макрос, но с именем `@Ранжирование_str`,
поэтому возможно употребление и русскоязычного варианта префикса строк с описаниями:
`Ранжирование" "`. Содержимое строк при этом остаётся без изменения.


## Функция (инфиксная операция) `⦸`

Поскольку ранжирования интересны не сами по себе, а лишь в совокупности, причём
нужны для отыскания затем некоторого консенсусного ранжирования, все промежуточные
шаги -- от записи ранжирований до формирования матрицы потерь, используемой потом
для реализации поиска консенсуса, -- эффективно скрыты за символом специальной операции,
применяемой формально для «комбинирования» ранжирований.

Символом `⦸` (он вводится как `\obslash[Tab]`) в пакете обозначается ассоциативная
и коммутативная бинарная операция, применимая к любой паре ранжирований (одних и
тех же альтернатив) и дающая в результате для любого их подобного набора нестандартную
матрицу потерь (называемую здесь «облегчённой» -- потому что в неё не включены слагаемые,
равные общему числу ранжирований, для всех внедиагональных элементов обычно используемой
матрицы потерь). Тем самым «облегчённая» матрица потерь оказывается антисимметричной,
что позволяет далее сделать поиск консенсусного ранжирования (и достижение самого
консенсуса) более наглядным.

На последовательность из двух и более ранжирований рассматриваемая операция воздействует
поочерёдно (слева направо), преобразуя её в результате в «облегчённую» матрицу потерь
для всего набора ранжирований.

> К сожалению, символ `⦸` в консоли пока ведёт себя несколько необычно: занимая
> при вводе лишь одну позицию, он отображается сразу в двух знакоместах, из-за чего
> после него соответствие символов и их позиций в строке нарушается, тем самым делая
> редактирование вводимой строки весьма проблематичным... По этой причине проще всего
> (если этот эффект проявляется -- и до тех пор, пока он не будет исправлен в будущем)
> использовать символ "инфиксно", завершая им каждое отдельное ранжирование на строке
> и записывая очередное ранжирование в следующей строке и т.д.


## Некоторые примеры

Отдельные примеры и возможные варианты записи одиночных ранжирований уже были приведены выше.

Рассмотрим, как могут быть записаны совокупности ранжирований, приводимые, например, в известной книге Б.Литвака *«Экспертная информация. Методы получения и анализа»*, М., 1982, на странице 78.
Если использовать англоязычный вариант имени макроса, то всё будет выглядеть так: 
```julia
ranking"a₂,a₄,a₁,a₃" ; ranking"a₁,a₃∼a₄,a₂" ; ranking"a₂∼a₃,a₄,a₁" ; ranking"a₃,a₂,a₁∼a₄"
```
Если же воспользоваться ещё и введённым символом операции `⦸`, то получаются такие
варианты выражений для «облегчённой» матрицы потерь:
```julia
⦸(ranking"a₂,a₄,a₁,a₃",
  ranking"a₁,a₃∼a₄,a₂",
  ranking"a₂∼a₃,a₄,a₁",
  ranking"a₃,a₂,a₁∼a₄")
```
или:
```julia
ranking"a₂,a₄,a₁,a₃"⦸
ranking"a₁,a₃∼a₄,a₂"⦸
ranking"a₂∼a₃,a₄,a₁"⦸
ranking"a₃,a₂,a₁∼a₄"
```

## Благодарности

Работа частично поддержана грантом РФФИ 18-07-00424.
